# JVM内存结构



```
class：编译后的java文件
class content：class文件存放的区域
class对象：class文件解析出的对象，放在方法区，如Class<Test> cl =   Test.class;
对象：new的java对象，放在堆，如Test t = new Test();
```

## 运行时数据区

* `方法区` Method Area 线程共享

```
方法区是一个规范，有2个实现，元空间和永久代
存放calss文件，常量池，静态变量

他们的关系？
元空间：1.8及之后，放在直接内存中，native memory
查看元空间大小命令：java -XX:+PrintFlagsFinal =versoin | grep Meta
MaxMetaspaceSize = 18446744073709547520B 最大值（等于说就是无限大了）
MetaspaceSize = 21807104B (20.75m)
jvm调优的时候可以设置这2个值，例如-XX:MaxMetaspaceSize=xxxx即可
元空间到底设置成多大？
建议是机器内存的1/32


永久代：1.8之前，放在堆上

为什么用元空间取代永久代？
1.硬件，现在的硬性越来越牛逼了，内存相当大
2.应用，以前的应用小，放在堆上无所谓，现在一个Spring就炸锅了。

```

* `虚拟机栈` VM Stack 线程私有

```
每创建一个线程，虚拟机就会为这个线程创建一个虚拟机栈，虚拟机栈表示Java方法执行的内存模型，每调用一个方法就会为每个方法生成一个栈帧（Stack Frame），用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用和完成的过程，都对应一个栈帧从虚拟机栈上入栈和出栈的过程。虚拟机栈的生命周期和线程是相同的

局部变量表：存放方法参数和方法内部定义的局部变量地址，以变量槽（Variable Slot）为最小单位
操作数栈：
动态链接：
方法出口：

虚拟机栈对堆的引用：虚拟机栈存放局部变量地址，而局部变量对象实际存放在堆上
```

* `本地方法栈` Native Method Stack 线程私有

```
是一个后入先出栈。
由于是线程私有的，生命周期随着线程，线程启动而产生，线程结束而消亡。
本地方法栈会抛出 StackOverflowError 和 OutOfMemoryError 异常
存放Native 方法
```


* `程序计数器` 线程私有

```
存放执行的指令和位置
```

* `堆`

```
年轻代：eden（占8/10内存），s1（占1/10内存），s2（占1/10内存）
老年代：old

为什么年轻代是内存占比1：3  ，老年代是3：2？
1、因为存储的数据不同，老年代需要存放年轻代GC不了转到老年代的对象，还要存放大对象。
2、分配空间担保：担保年轻代出现内存不足，剩余活跃对象能有地方存放

为什么eden和s1,s2比例是 8:1:1
copy算法，因为在大量数据测试下，90-95%的对象都会被回收，所以取了最大值10%，用来存放活跃对象。

大对象：>=eden区剩余内存大小

方法区对堆的引用：方法区存放class对象，而对象实际存在堆
```