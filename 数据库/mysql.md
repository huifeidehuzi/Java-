# MySQL

```
本篇所有笔记都是依据InnoDB引擎记录
```
###数据结构
* `主键索引下的数据结构` 注：图中name、age、like为自定义字段，后面的数字是字段对应的值，冒号前的值是主键id，页目录是主键索引字段的值得来的，比如主键是1，那么页目录的值就是1
![](media/15784748403733/15785608445331.jpg)
    
* `辅助索引下的数据结构` 注：图中name、age为自定义字段，后面的数字是字段对应的值。冒号后的值是主键id，页目录是按辅助索引字段的值组合得来的，比如name是1，age是1，那么组合的页目录是11
![](media/15784748403733/15786499490964.jpg)

```
不同之处：
    1.主键索引下的结构是主键+行记录，辅助索引下的结构是辅助索引字段的值+主键，比如：1:name1_age1_like1和name1_age1:1的区别
    2.辅助索引下的目录页中多了个主键，是为了出现辅助索引值相同（比如联合索引）目录页中内容唯一，导致无法查找节点的问题（就是它不知道到底是去找左节点还是找右节点）
``` 
* `相关介绍`
    
```
InnoDB的数据结构是Bree+（图太大就画了这么点）
如上图，一共12条数据，分别存放在两页中，每页6条
每行数据结构为：id(pk)、name、age、like，除了自定义字段之外，MySQL会为每个记录默认的添加一些列（隐藏列）
    1.row_id：自动增长主键，只会在没有设置主键和唯一键的场景下才有，方便自动排序和查询
    2.transcation_id：事务id
    3.roll_pointer：回滚指针
1.插入数据，InnoDB会按主键/唯一键/row_id自动排序
注：创建表时会自动创建一个页，当这个页的空间满了之后，会将该页copy一份出来，再新建一个页继续存放数据，将原来的第一个页改为目录页，copy出来的页变为第一个页

2.mysql会将数据分组后对应一个页目录，用来快速查询记录，比如查找id为4的数据，则会先找到为3的页目录，然后在对应的记录中查找id为4的记录

3.每页数据会对应一个目录页，目录页中会存放每页最小的id和对应的页码，也是用来快速查询到对应的记录，比如查找id为4的数据，会找到目录页中id为1的页码，然后找到对应的页目录再找到id为4的记录

4.每次查询，mysql会将数据所在页(16kb)的数据查询出来放到内存中，下次查询如果内存中有需要查询的数据，就不用走磁盘了。这也就是所谓的局部性原理

5.回表：辅助索引下找到对应的数据后，会根据对应的主键再回表找到主键对应的数据，因为辅助索引节点是不存储整行数据的

建议
    1.设置主键为自增长，合理的分配每个字段的类型和长度，让一页中尽可能多的存入数据，减少页的扩张，提升查询性能
    2.如有需要，可以先排好序再分组
    3.如果分组有联合索引的字段，建议先查询首字段，再分组就可以用到索引了,比如where a>0 group by b,c 这里先查询a>0的数据（等同于不加a>0的查询效果，也是查询全表，但是这里可以用到索引），就可以用到索引，查出来的数据是有序的，b,c再排序就可以用到索引
```
###索引

```
索引的结构也是Bree+
1.最左前缀/匹配原则
比如ABC（都是int类型）三个字段建了联合索引，那么查询条件中必须带上A才会用到索引，比如where A=1 and B>1 and c<1 

这是因为当查询条件带上A的时候（比如A=1），此时查找的条件值是1**(*为B和C的值)，那么1**就会按查询条件去比较节点上的索引值，找到对应的记录。

如果不带上A(比如B=1 AND C=1)，此时查找的条件值是*11，那么就没法去比较各节点上的索引值，因为mysql不知道这个值的范围到底是多大，所以就用不上索引

比如A>1 AND B=2, A能用到索引，B可能用不到，因为首先会找到A>1的所有节点，然后排序好，此时B字段的值是无序的，所以用不到索引,其他查询同理
如：234 298 335 ，A字段的值是每个值是首位且有序的，而B是第二位且无序的

like %100% 或 %100也是用不到索引的，因为*100*或*100也是没办法去比较的，只有100%这种（100*）才会匹配到值，用到索引

2.范围查询
比如A>1 AND A<4，先会查找A=1 和 A=4的节点，然后取这2个节点中间的记录即可，其他查询同理
```
###事务
* `基本常识`

```
ACID：原子性，一致性，隔离性，持久性
autocommit：自动提交属性，默认打开
隐式提交：开始事务后，做了些修改/新增的操作，如果在事务未提交之前的过程中做了create、alter、drop等DDL操作，mysql会自动提交当前事务
```
* `隔离性`

```
1.读未提交
一个事务可以读到其他事务未提交的数据，会出现脏读
脏读：一个事务查到了其他事务修改过但是未提交的数据

2.读已提交
一个事务只能读到其他事务已提交事务修改过的数据，并且其他事务每当对数据进行修改，都能读到最新的值，会出现不可重复度，幻读
幻读：如果一个事务先根据某些条件查出一些数据，之后其他事务又向表中插入了符合查询条件的数据，那么之前的事务再次按这些条件查询时，会把其他事务插入的数据也查出来
不可重复读：如果一个事务先根据某些条件查出一些数据，之后其他事务修改了符合查询条件的某些数据，那么之前的事务再次按这些条件查询时，会把其他事务修改的数据也查出来
区别：不可重复读是由于另一个事务对数据的更改所造成的，而幻读是由于另一个事务插入或删除引起的

3.可重复读
一个事务第一次读过某些记录后，即使其他事务对这些数据进行修改，该事务再读这些记录仍然是第一次读到的值，这种隔离界别可以解决不可重复读和幻读（数据库标准里可重复读是会出现幻读的，但mysql解决了幻读这个问题）

4.串行化
不允许对同一条数据同时读和写(只能同时读)并发操作，不会出现脏读和幻读，性能较低
```
* `版本链` 不同事务间读取/修改数据的逻辑图

![](media/15784748403733/15789674156016.jpg)


```
如上图，第一列至第五列都是自定义字段值，第六列是事务id，第七列是回滚指针，每个指针都会指向上一行（按事务id降序）
每个事务开启都会生成一个事务id和回滚指针，每个事务对每一行数据中多个或者单个字段做修改的操作都会生成对应的一行记录，查询时就会按照对应的事务id获取对应的记录
```

###锁

* `基本常识`


```
读锁：共享锁，shared locks，S锁
写锁：排他锁，exculusive locks，X锁
select：不加锁
事务结束后，事务内的锁都会被释放
```

* `写操作`


```
DELETE：先对记录上X锁，在执行删除操作
INSERT：会先加“隐式锁”，保证新插入的记录在事务提交前不能被别的事务查到
UPDATE:
        如果修改前后没有导致存储空间变化，那么会先上X锁，再对记录进行修改
        如果修改前后导致存储空间变化，那么会先上X锁，然后将记录删除，再新增一条新记录
        
隐式锁：一个事务插入一条记录后还没有提交就会在这条记录上保存事务id（参考事务版本链）
        此时如果有其他事务来对这条记录加锁，发现事务id不一致，则会上X锁，相当于在插入一条记录时，隐式的给这条记录加了一把X锁
```

* `读锁`


```
select * from table lock in share mode
将查找出的数据加S锁，期间其他事务也可以对这些数据加S锁，但不能加X锁
使用场景：查出数据后其他事务不允许修改，可能自己也不能修改，因为其他事务也可以对数据加S锁

select * from table for update
将查找出的数据加X锁，其他事务不允许加X和S锁（悲观锁）
使用场景：查出数据后其他事务不能写和读，只能自己读和写
注：读已提交隔离级别下只会对查出来的所有行记录加锁，且能插入匹配查询条件的数据，比如查询name='zhangsan',加锁后，还能插入name='zhangsan'的数据
    可重复读隔离级别下只会对查出来的所有行记录加锁，不能插入匹配查询条件的数据，比如查询name='zhangsan',加锁后，不能插入name='zhangsan'的数据，或者 age>14,加锁后，不能插入age>14的数据，解决了幻读问题
    可重复读隔离级别下如果查询字段没有索引，会对数据库所有行加X锁，其他事务不能对任何一行记录加X锁
    
```