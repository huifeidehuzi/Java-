# 数据结构&算法

## 数据结构
### 树
* `二叉树`

```
左节点<根节点<右节点
```

* `红黑树`

```
底层是(特殊的)二叉查找树
左节点<根节点<右节点

性质：
1.每个节点不是红色就是黑色
2.不可能有连在一起的红色节点
3.根节点都是黑色，入度为0
4.每个红色节点的2个子节点都是黑色，叶子节点都是黑色，出度为0，满足了性质就可以近似的平衡，不一定要红黑，也可以用其他的

不满足上述性质的时候会自旋变颜色以满足上述性质

变换规则：
1.变颜色，红变黑 黑变红
2.左旋，逆时针旋转，要旋转的节点(N1)往上一级，被旋转的节点(N2)往下一级，N1的左子树变成N2的右子树
3.右旋，顺时针旋转，要旋转的节点(N1)往上一级，被旋转的节点(N2)往下一级，N1的右子树变成N2的左子树
4.所有插入的点默认为红色


插入规则与二叉树一致。左小右大
1.当前节点的父节点为红色，且叔叔节点为红色变换规则如下：
1>把父节点变为黑色，叔叔节点也设为黑色
2>把爷爷节点设为红色
3>自旋
```

* `B树`

```
B-Tree
性质：
1.节点最多含有m颗子树，m-1关键字(数据)(m>=2)
比如一个5阶的树，最多含有5颗子树，能存储4个数据
2.除根节点和叶子节点外，其他每个节点至少有ceil(m/2)个子节点，ceil为向上取整
3.若根节点不是叶子节点，则最少有2颗子树
不满足上述性质的时候，会分裂以满足上述性质
分裂：从中间分开，分成两颗子树
比如一个5阶的树：
数据为：1 3 4 8 13 7 
树结构为：
     [7]     
[1][3] [8][13] 
插入1 3 8 13后再插入7，就分裂成上面的结构
      [7]      [12]
[1][3]   [8][11]  [13][15]
继续插入12 ，则分裂成上面的结构
插入排序：插入数据规则跟二叉树一致。左节点<根节点<右节点
查找数据会遍历范围内的所有节点，性能低，开销大
B+Tree
相比B树，有以下区别：
1.叶子节点连起来了，使用的是双向链表，解决范围查找
2.数据和节点一样多，因为数据存在叶子节点上
3.非叶子节点不存储数据
4.查找数据都会查叶子节点
                     [4,11,15]
     [2,4]             [9,11]            [13,15]
[1,2]-><-[3,4]-><-[7,9]-><-[10,11]-><-[12,13]-><-[14,15]
分裂：
把叶子节点最大的值放到父节点，查找非常快
```

## 算法
* `二分查找`

```
查找的数据必须是有序的。中间值计算方法：(min+max)/2
比如猜1个数，56
1-100的数据， 中间值为50，小于56
继续找，中间值重新计算75，大于56
此时，这个数就在50-75之间，中间值为62，大于56  
此时，这个数就在50-62之间，中间值为56，等于56，找到了

```