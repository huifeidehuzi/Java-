# 分布式事务

## 概述

随着技术的不断发展，业务不断的推进，我们的系统从单机架构到分布式架构的转变是必然的，特别是现在的微服务架构，以至于不得不面对一个问题，分布式事务。

在单机架构的时候，数据都在一个DB上，所以不涉及到多DB间的事务，而当系统架构演化为分布式架构后，数据落到不同的DB上，一连串链式调用，如：下单流程，需要生成订单id，扣减库存，优惠券等等。如果其中任何一个服务失败/异常，需要对数据回滚，反之提交。这就是分布式事务的作用



## 一致性

### **强制一致性**

一连串链式调用要么成功，要么失败。不能容忍数据更新/插入后即时访问不到的情况

### 弱一致性

允许一连串链式调用中某些服务失败/异常，可通过后续手段补偿保证一致性。容忍数据更新/插入后即时访问不到的情况

### 最终一致性

允许一连串链式调用中某些服务失败/异常，一段时间后数据最终会保证一致性。容忍数据更新/插入后即时访问不到的情况



## CAP原则

在一个分布式系统中，一致性、可用性、分区容错性，三者不可兼得



**一致性（C）**：所有节点在同一时间的数据是否一致

**可用性（A）**：集群中部分节点宕机后，集群是否还能支持读写请求

**分区容错性（P）**：系统如果不能在某个时间段内达成数据一致性，则发生了分区的情况，必须就当前操作在C和A之间做出选择



CAP 原则的精髓就是要么 AP，要么 CP，要么 AC，但是不存在 CAP



## 幂等

多次执行更新/插入操作只会对数据进行一次操作，简单来说就是多次执行得到的结果都是相同的，这是分布式事务业务逻辑中必备条件之一



## 分布式事务解决方案

### 两阶段提交

顾名思义，分两个阶段提交，其中还存在一个协调者（事务管理器），第一阶段，事务管理器确认所有参与者是否就绪，如果有任何一个返回NO，则回滚事务，反之直接第二阶段提交事务

**注：所有的分布式事务框架都是由两阶段提交演化而来的**

[![DS6rWR.jpg](https://s3.ax1x.com/2020/11/13/DS6rWR.jpg)](https://imgchr.com/i/DS6rWR)

**存在问题：**

- 同步阻塞：占用公共资源（事务管理器），只有当前事务提交后，后面排队的事务才能继续走
- 单点故障：当事务管理器发生故障/挂掉，那么当前及后面排队的事务则会一直阻塞或不可用
- 数据不一致：当事务管理器发送commit请求后，如果网络异常，其中一部分没有收到commit请求的参与者则无法执行业务逻辑提交事务



### TCC

TCC相比上述的两阶段提交，解决了其中几个缺点：

1. 事务管理器单点：由主业务方发起并完成整个事务。业务活动管理器也变成多点，引入集群
2. 同步阻塞：引入超时补偿机制，不会占用整个资源
3. 数据一致性：有了补偿机制后，由业务活动管理器控制一致性



TCC大致流程如下：

1. Try：预检查/尝试执行：完成业务执行前的必要检查，如：下单时商品的库存检查
2. Confirm：执行业务，需具备幂等，因为在执行失败后需要进行重试
3. Cancel：取消执行，需具备幂等，因为执行失败后也需要重试



**存在问题：**

- 需要实现Try、Confirm、Cancel 三个接口，代码复杂度高



### 本地消息表

该方案中会有消息生产者与消费者，大致流程图如下

[![DpK5LT.jpg](https://s3.ax1x.com/2020/11/13/DpK5LT.jpg)](https://imgchr.com/i/DpK5LT)



1. 系统A被调用发生数据操作时，首先更新业务数据，然后往本地消息表中插入一条记录，这2个操作在同个事务内完成
2. 定时将本地消息写入到MQ
3. 系统B消费MQ消息，处理业务逻辑。如果处理失败可以重试或者直接回滚，这取决于开发者



**需要的条件：**

1. 消费者与生产者接口需要支持幂等
2. 需要一张本地消息表
3. 需要提供补偿机制
4. 需要生产者提供回滚接口



### 最大努力通知

最简单的一种柔性事务，适用于实时性要求不高，业务敏感度低且不影响主业务流程的场景

1. 系统A本地事务执行完成发送消息到MQ
2. 专门消费MQ消息的服务消费消息，调用系统B
3. 如果处理成功就ok，反之不断重试，重试N次不成功则放弃

